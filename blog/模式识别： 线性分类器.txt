


 
一、实验目的和要求 
目的： 
了解线性分类器，对分类器的参数做一定的了解，理解参数设置对算法的影响。
 
要求： 
1. 产生两类样本
2. 采用线性分类器生成出两类样本的分类面
3. 对比线性分类器的性能，对比参数设置的结果
二、实验环境、内容和方法 
环境：windows 7，matlab R2010a
内容：通过实验，对生成的实验数据样本进行分类。
 
三、实验基本原理 
感知器基本原理： 
1.感知器的学习过程是不断改变权向量的输入，更新结构中的可变参数，最后实现在有限次迭代之后的收敛。感知器的基本模型结构如图1所示：

图1 感知器基本模型 
其中，X输入，Xi表示的是第i个输入；Y表示输出；W表示权向量；w0是阈值，f是一个阶跃函数。
感知器实现样本的线性分类主要过程是：特征向量的元素x1，x2，……，xk是网络的输入元素，每一个元素与相应的权wi相乘。，乘积相加后再与阈值w0相加，结果通过f函数执行激活功能，f为系统的激活函数。因为f是一个阶跃函数，故当自变量小于0时，f= -1；当自变量大于0时，f= 1。这样，根据输出信号Y，把相应的特征向量分到为两类。
然而，权向量w并不是一个已知的参数，故感知器算法很重要的一个步骤即是寻找一个合理的决策超平面。故设这个超平面为w，满足：
        （1）
引入一个代价函数，定义为：
        （2）
其中，Y是权向量w定义的超平面错误分类的训练向量的子集。变量定义为：当时，= -1；当时，= +1。显然，J(w)≥0。当代价函数J(w)达到最小值0时，所有的训练向量分类都全部正确。为了计算代价函数的最小迭代值，可以采用梯度下降法设计迭代算法，即：
        （3）
其中，w(n)是第n次迭代的权向量，有多种取值方法，在本设计中采用固定非负值。由J(w)的定义，可以进一步简化（3）得到：
        （4）
通过（4）来不断更新w，这种算法就称为感知器算法（perceptron algorithm）。可以证明，这种算法在经过有限次迭代之后是收敛的，也就是说，根据（4）规则修正权向量w，可以让所有的特征向量都正确分类。
 
 
Fisher分类器原理：
Fisher线性判别分析的基本思想：通过寻找一个投影方向（线性变换，线性组合），将高维问题降低到一维问题来解决，并且要求变换后的一维数据具有如下性质：同类样本尽可能聚集在一起，不同类的样本尽可能地远。 
Fisher线性判别分析，就是通过给定的训练数据，确定投影方向W和阈值y0，即确定线性判别函数，然后根据这个线性判别函数，对测试数据进行测试，得到测试数据的类别。
 
1．线性投影与Fisher准则函数 
在两类问题中，假定有个训练样本其中个样本来自类型，个样本来自类型，。两个类型的训练样本分别构成训练样本的子集和。 
令：， (4.5-1) 
是向量通过变换得到的标量，它是一维的。实际上，对于给定的，就是判决函数的值。 
由子集和的样本映射后的两个子集为和。因为我们关心的是的方向，可以令，那么就是在方向上的投影。使和最容易区分开的方向正是区分超平面的法线方向。如下图： 

图中画出了直线的两种选择，图(a)中，和还无法分开，而图(b)的选择可以使和区分开来。所以图(b)的方向是一个好的选择。 
下面讨论怎样得到最佳方向的解析式。 
各类在维特征空间里的样本均值向量： 
， (4.5-2) 
通过变换映射到一维特征空间后，各类的平均值为： 
， (4.5-3) 
映射后，各类样本"类内离散度"定义为：  
， (4.5-4) 
显然，我们希望在映射之后，两类的平均值之间的距离越大越好，而各类的样本类内离散度越小越好。因此，定义Fisher准则函数： 
 (4.5-5) 
使最大的解就是最佳解向量，也就是Fisher的线性判别式。 
2．求解 
从的表达式可知，它并非的显函数，必须进一步变换。 
已知：，, 依次代入(4.5-1)和(4.5-2)，有： 
， (4.5-6) 
所以： 
 (4.5-7) 
其中： (4.5-8) 
是原维特征空间里的样本类内离散度矩阵，表示两类均值向量之间的离散度大小，因此，越大越容易区分。 
将(4.5-6)和(4.5-2)代入(4.5-4)式中： 


 (4.5-9) 
其中：， (4.5-10) 
因此： (4.5-11) 
显然： (4.5-12) 
称为原维特征空间里，样本"类内离散度"矩阵。 
是样本"类内总离散度"矩阵。 
为了便于分类，显然越小越好，也就是越小越好。 
将上述的所有推导结果代入表达式： 
 —— 广义Rayleigh商 (4.5-13) 
式中和皆可由样本集计算出。 
用lagrange乘子法求解的极大值点。 
令分母等于非零常数，也就是：。 
定义lagrange函数：  
 (4.5-14) 
对求偏导数： 

令得到： 
 (4.5-15) 
从上述推导(4.5-10)～(4.5-12)可知，是维特征的样本协方差矩阵，它是对称的和半正定的。当样本数目时，是非奇异的，也就是可求逆。 
则： (4.5-16) 
问题转化为求一般矩阵的特征值和特征向量。令，则是的特征根，是的特征向量。 


 (4.5-17) 
式中： 

是一个标量。所以总是在方向上。将(4.5-17)代入到(4.5-15)，可以得到： 

其中，是一个比例因子，不影响的方向，可以删除，从而得到最后解： 
 (4.5-18) 
就使取得最大值，可使样本由维空间向一维空间映射，其投影方向最好。是一个Fisher线性判断式。 
讨论： 
如果，，则样本线性不可分。 
，未必线性可分。 
不可逆，未必不可分。 
3.Fisher算法步骤  
由Fisher线性判别式求解向量的步骤： 
① 把来自两类的训练样本集分成和两个子集和。 
② 由，，计算。 
③ 由计算各类的类内离散度矩阵，。 
④ 计算类内总离散度矩阵。 
⑤ 计算的逆矩阵。 
⑥ 由求解。 
这一节所研究的问题针对确定性模式分类器的训练，实际上，Fisher的线性判别式对于随机模式也是适用的。 
Fisher算法注释: 
（1）Fisher方法可直接求解权向量； 
（2）对线性不可分的情况，Fisher方法无法确定分类，Fisher可以进一步推广到多类问题中去。 
 
 
四、实验过程描述 
总结： 
 
采用感知器算法实现data1.m的数据分类流程如图2所示：

图2 单层感知器算法程序流程 
 
Fisher准则求得分类面的性能好坏一定程度上受样本影响。有的时候Fisher可以完全正确分类，有的时候分类结果虽不是完全正确但尚可以接受，有的时候则很不理想。
 
五、实验结果 
感知器分类结果： 

Fisher线性分类器分类结果：  

六、附录代码
单层感知分类器： 
function Per1()
 
clear all;
close all;
 
%样本初始化
x1(1,1)=5.1418; x1(1,2)=0.5950;
x1(2,1)=5.5519; x1(2,2)=3.5091;
x1(3,1)=5.3836; x1(3,2)=2.8033;
x1(4,1)=3.2419; x1(4,2)=3.7278;
x1(5,1)=4.4427; x1(5,2)=3.8981;
x1(6,1)=4.9111; x1(6,2)=2.8710;
x1(7,1)=2.9259; x1(7,2)=3.4879;
x1(8,1)=4.2018; x1(8,2)=2.4973;
x1(9,1)=4.7629; x1(9,2)=2.5163;
x1(10,1)=2.7118; x1(10,2)=2.4264;
x1(11,1)=3.0470; x1(11,2)=1.5699;
x1(12,1)=4.7782; x1(12,2)=3.3504;
x1(13,1)=3.9937; x1(13,2)=4.8529;
x1(14,1)=4.5245; x1(14,2)=2.1322;
x1(15,1)=5.3643; x1(15,2)=2.2477;
x1(16,1)=4.4820; x1(16,2)=4.0843;
x1(17,1)=3.2129; x1(17,2)=3.0592;
x1(18,1)=4.7520; x1(18,2)=5.3119;
x1(19,1)=3.8331; x1(19,2)=0.4484;
x1(20,1)=3.1838; x1(20,2)=1.4494;
x1(21,1)=6.0941; x1(21,2)=1.8544;
x1(22,1)=4.0802; x1(22,2)=6.2646;
x1(23,1)=3.0627; x1(23,2)=3.6474;
x1(24,1)=4.6357; x1(24,2)=2.3344;
x1(25,1)=5.6820; x1(25,2)=3.0450;
x1(26,1)=4.5936; x1(26,2)=2.5265;
x1(27,1)=4.7902; x1(27,2)=4.4668;
x1(28,1)=4.1053; x1(28,2)=3.0274;
x1(29,1)=3.8414; x1(29,2)=4.2269;
x1(30,1)=4.8709; x1(30,2)=4.0535;
x1(31,1)=3.8052; x1(31,2)=2.6531;
x1(32,1)=4.0755; x1(32,2)=2.8295;
x1(33,1)=3.4734; x1(33,2)=3.1919;
x1(34,1)=3.3145; x1(34,2)=1.8009;
x1(35,1)=3.7316; x1(35,2)=2.6421;
x1(36,1)=2.8117; x1(36,2)=2.8658;
x1(37,1)=4.2486; x1(37,2)=1.4651;
x1(38,1)=4.1025; x1(38,2)=4.4063;
x1(39,1)=3.9590; x1(39,2)=1.3024;
x1(40,1)=1.7524; x1(40,2)=1.9339;
x1(41,1)=3.4892; x1(41,2)=1.2457;
x1(42,1)=4.2492; x1(42,2)=4.5982;
x1(43,1)=4.3692; x1(43,2)=1.9794;
x1(44,1)=4.1792; x1(44,2)=0.4113;
x1(45,1)=3.9627; x1(45,2)=4.2198;
 
 
x2(1,1)=9.7302; x2(1,2)=5.5080;
x2(2,1)=8.8067; x2(2,2)=5.1319;
x2(3,1)=8.1664; x2(3,2)=5.2801;
x2(4,1)=6.9686; x2(4,2)=4.0172;
x2(5,1)=7.0973; x2(5,2)=4.0559;
x2(6,1)=9.4755; x2(6,2)=4.9869;
x2(7,1)=9.3809; x2(7,2)=5.3543;
x2(8,1)=7.2704; x2(8,2)=4.1053;
x2(9,1)=8.9674; x2(9,2)=5.8121;
x2(10,1)=8.2606; x2(10,2)=5.1095;
x2(11,1)=7.5518; x2(11,2)=7.7316;
x2(12,1)=7.0016; x2(12,2)=5.4111;
x2(13,1)=8.3442; x2(13,2)=3.6931;
x2(14,1)=5.8173; x2(14,2)=5.3838;
x2(15,1)=6.1123; x2(15,2)=5.4995;
x2(16,1)=10.4188; x2(16,2)=4.4892;
x2(17,1)=7.9136; x2(17,2)=5.2349;
x2(18,1)=11.1547; x2(18,2)=4.4022;
x2(19,1)=7.7080; x2(19,2)=5.0208;
x2(20,1)=8.2079; x2(20,2)=5.4194;
x2(21,1)=9.1078; x2(21,2)=6.1911;
x2(22,1)=7.7857; x2(22,2)=5.7712;
x2(23,1)=7.3740; x2(23,2)=2.3558;
x2(24,1)=9.7184; x2(24,2)=5.2854;
x2(25,1)=6.9559; x2(25,2)=5.8261;
x2(26,1)=8.9691; x2(26,2)=4.9919;
x2(27,1)=7.3872; x2(27,2)=5.8584;
x2(28,1)=8.8922; x2(28,2)=5.7748;
x2(29,1)=9.0175; x2(29,2)=6.3059;
x2(30,1)=7.0041; x2(30,2)=6.2315;
x2(31,1)=8.6396; x2(31,2)=5.9586;
x2(32,1)=9.2394; x2(32,2)=3.3455;
x2(33,1)=6.7376; x2(33,2)=4.0096;
x2(34,1)=8.4345; x2(34,2)=5.6852;
x2(35,1)=7.9559; x2(35,2)=4.0251;
x2(36,1)=6.5268; x2(36,2)=4.3933;
x2(37,1)=7.6699; x2(37,2)=5.6868;
x2(38,1)=7.8075; x2(38,2)=5.0200;
x2(39,1)=6.6997; x2(39,2)=6.0638;
x2(40,1)=5.6549; x2(40,2)=3.6590;
x2(41,1)=6.9086; x2(41,2)=5.4795;
x2(42,1)=7.9933; x2(42,2)=3.3660;
x2(43,1)=5.9318; x2(43,2)=3.5573;
x2(44,1)=9.5157; x2(44,2)=5.2938;
x2(45,1)=7.2795; x2(45,2)=4.8596;
x2(46,1)=5.5233; x2(46,2)=3.8697;
x2(47,1)=8.1331; x2(47,2)=4.7075;
x2(48,1)=9.7851; x2(48,2)=4.4175;
x2(49,1)=8.0636; x2(49,2)=4.1037;
x2(50,1)=8.1944; x2(50,2)=5.2486;
x2(51,1)=7.9677; x2(51,2)=3.5103;
x2(52,1)=8.2083; x2(52,2)=5.3135;
x2(53,1)=9.0586; x2(53,2)=2.9749;
x2(54,1)=8.2188; x2(54,2)=5.5290;
x2(55,1)=8.9064; x2(55,2)=5.3435;
 
 
for i=1:45 r1(i)=x1(i,1);end;
for i=1:45 r2(i)=x1(i,2);end;
for i=1:55 r3(i)=x2(i,1);end;
for i=1:55 r4(i)=x2(i,2);end;
 
figure(1);
%plot(r1,r2,'*',r3,r4,'o');
hold on;%保持当前的轴和图像不被刷新，在该图上接着绘制下一图
 
plot(r1,r2,'ro',...
'LineWidth',1,...
'MarkerEdgeColor','k',...
'MarkerFaceColor',[1 0 0],...
'MarkerSize',7);
 
plot(r3,r4,'bo',...
'LineWidth',1,...
'MarkerEdgeColor','k',...
'MarkerFaceColor',[0 0 1],...
'MarkerSize',7) 
 
 
 
x1(:,3) = 1;% 考虑到不经过原点的超平面，对x进行扩维
x2(:,3) = 1;% 使x'=[x 1]，x为2维的，故加1扩为3维
 
%进行初始化
w = rand(3,1);% 随机给选择向量，生成一个3维列向量
p = 1; %p0非负正实数
ox1 = -1;% 代价函数中的变量
ox2 = 1;% 当x属于w1时为-1，当x属于w2时为1
s = 1;% 标识符，当s=0时，表示迭代终止
n = 0;% 表示迭代的次数
w1 = [0;0;0];
 
while s %开始迭代
J = 0; %假设初始的分类全部正确
j = [0;0;0]; %j=ox*x
for i = 1:45
if (x1(i,:)*w)>0 %查看x1分类是否错误，在x属于w1却被错误分类的情况下，w'x<0
w1 = w; %分类正确，权向量估计不变
else %分类错误
j = j + ox1*x1(i,:)';% j=ox*x。进行累积运算
J = J + ox1*x1(i,:)*w;% 感知器代价进行累积运算
end
end
for i = 1:55
if (x2(i,:)*w)<0%查看x2分类是否错误，在x属于w2却被错误分类的情况下，w'x>0
w1 = w; %分类正确，权向量估计不变
else %分类错误
j = j + ox2*x2(i,:)';% j=ox*x。进行累积运算
J = J + ox2*x2(i,:)*w;% 感知器代价进行累积运算
end
end
if J==0 %代价为0，即分类均正确
s = 0; %终止迭代
else
w1 = w - p*j;% w(t+1)=w(t)-p(ox*x)进行迭代
p=p+0.1;% 调整p
n = n+1; %迭代次数加1
end
w = w1;% 更新权向量估计
end
x = linspace(0,10,5000);% 取5000个x的点作图
y = (-w(1)/w(2))*x-w(3)/w(2);% x*w1+y*w2+w0=0,w=[w1;w2;w0]
plot(x,y,'r');% 用红线画出分界面
disp(n);% 显示迭代的次数
axis([1,12,0,8])% 设定当前图中，x轴范围为1-12，为y轴范围为0-8
end
 
 
 
 
 
 
Fisher分类方法： 
 
clear
clc
 
N=60;
[m1,m2,X1,Y1,X2,Y2]=SampleGen(N); %样本产生程序
M1=[mean(X1) mean(Y1)]'; %计算均值
M2=[mean(X2) mean(Y2)]';
S1=zeros(2,2);
S2=zeros(2,2);
%save data m1 m2 X1 X2 Y1 Y2
for i=1:length(X1) %类内离散度计算
S1=S1+(m1(:,i)-M1)*(m1(:,i)-M1)';
end
for i=1:length(X2)
S2=S2+(m2(:,i)-M2)*(m2(:,i)-M2)';
end
Sw=S1+S2;
W=(M1-M2)\Sw; %分类面法向量计算
w0=[mean([X1 X2]) mean([Y1 Y2])]'; %w0 计算
i=min([X1 X2]):0.001:max([X1 X2]);
U=W*w0/W(2)-W(1)/W(2).*i;
plot(X1,Y1,'.',X2,Y2,'r*',i,U,'K')
legend('w1','w2','fisher')
 
 
样本产生函数： 
 
function [m1,m2,X1,Y1,X2,Y2] = SampleGen(N)
x = randn(1,N);
y = randn(1,N);
 
i1 = 1;
i2 = 1;
 
for i = 1:N
if x(1) < 2*y(i)
X1(i1) = x(i);
Y1(i1) = y(i);
i1 = i1 + 1;
elseif x(i) > 2*y(i)
X2(i2) = x(i)
Y2(i2) = y(i)
i2 = i2 + 1;
end
end
 
plot(X1,Y1,'.');
hold on;
plot(X2,Y2,'r*');
 
m1 = ones(2,length(X1));
m2 = ones(2,length(X2));
 
for i = 1:length(X1)
m1(1,i) = X1(i);
m1(2,i) = Y1(i);
end
 
for i = 1:length(X2)
m2(1,i) = X2(i);
m2(2,i) = Y2(i);
end
 
end
 
 
 
 
 


